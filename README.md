# 一些笔记

## 一.编译器选择

C和C++是历史悠久的编程语言，因而为其开发编译器的厂商非常之多，但使用频率最高的编译环境主要还是以下三种。

### 1.MSVC

微软的C/C++开发环境，主要在Windows平台使用，也是本实验课程所选中的开发环境。MSVC是Windows平台下效率最高的C/C++编译器，但是有大量MSVC独有特性（如scanf_s，printf_s等“安全”函数）

MSVC包含C编译器和C++编译器，相比C和C++的标准支持C++的支持最快且最全，现在支持实验性模块系统。

### 2.GCC

GCC，全称GNU编译器合集(GNU Compiler Collection)，是GNU计划的核心软件。它可以编译大多数流行的编程语言，其中对C/C++的支持最为重要。相比MSVC，GCC支持C语言标准更新，并且可以在多个平台上进行使用。GCC是GNU/Linux的主力编译器，一般通过安装build-essentials即可安装。

在Windows平台，GCC主要通过MSYS2下安装MinGW环境使用，以避免各种环境冲突问题。

### 3.Clang

Clang是基于llvm的(Objective)C(++)编译器，支持多个平台，在Windows环境下主要通过安装llvm工具集来使用。Clang受苹果赞助，其主要也用于MacOS等场景，为苹果的MacOS、iOS等系统编译软件。由于基于llvm，clang生成目标和llvm完全同步，支持几乎所有平台。

虽然本实验课程并未使用clang作为编译器，但使用了clangd作为IDE的LSP，并使用clang-format对代码进行格式化。

## 二、IDE选择

IDE即集成式开发环境，是编写程序使用到的工具，可以为程序编写提供代码跳转、自动补全、语法检查、编译调试等方便的功能，而无须和底层编译器等打交道。

### 1.Visual Studio

Visual Studio 是微软开发的多功能IDE，可以进行Visual  C/C++ 和 .NET 开发。

Visual Studio 是世界上最为强大的IDE，是世界使用频率第二的IDE。

Visual Studio提供了免费的社区版和收费授权的企业版。

### 2.Clion

Clion是JetBrain公司开发的用于C、C++、Rust等系统级编程语言开发的IDE。

Clion外观与功能和用于Java开发的IDEA类似。

Clion只提供了付费版本，但学生可以凭借学校邮箱或学信网证明来获取免费的学生版本，亦可通过长期开发开源项目向JetBrain申请。

### 3.Dev C++

Dev C++是一款早已停止更新的IDE，常被用于算法竞赛等场合，内置编译器为MinGW环境。

### 4.Visual Studio Code

实际上，VSCode并不能称之为IDE。VSCode本身是轻量级代码编辑器，可以通过插件扩展其功能。在安装了Clangd插件后即可开发C/C++项目。VSCode内置了JavaScript和TypeScript以及HTML、CSS语言功能，但仍可通过安装插件来支持市面上几乎所有语言。

VSCode是近年来最为火热的编辑器，使用率在全球高居第一位。

### 5.VIM

vim是对文本编辑软件vi的改进，它是一个历史悠久的代码编辑器，具有高度可订制性。vim不鼓励使用鼠标，它是一个有模式编辑器，可以通过键盘完成一切操作。在一些高级程序员手中，它可以是效率最高的编辑器，甚至于广义IDE。

## 三、常见问题（MSVC环境下）

### 1._s结尾的安全函数

历史上，`scanf`、`gets`、`printf`等函数经常用于控制台输入输出。然而，由于C语言字符串特性，即总是由`'\0'`结尾，而这些函数在读入字符串时亦以此作为标准。一旦传入字符串不遵循这个规则时，这些函数就会一直读取导致越界访问，轻则数据出错，中则程序崩溃，重则造成程序易受攻击的的安全漏洞。因此，C语言标准加入了对应的`scanf_s`、`gets_s`、`printf_s`等安全输入输出函数，其要求每一个字符或字符串参数之后要紧跟一个缓存区大小参数，用以在没有读取到字符串结尾时做为兜底停止读取。

然而，即使是通过这种方式进行输入也已经过时了。目前C语言最新标准已经不推荐`scanf_s`这种格式化输入函数，其容易遭遇缓存区问题而无法正确读入数据。目前更为保险的做法是使用`stdlib.h`头文件中的`fgets`配合字符串格式化分析工具来从控制台读取数据。

### 2.scanf不能正常工作

如上所述，`scanf`已经是过时的函数，如需使用，请尽可能不要在格式化符之间加入其他字符影响输入输出。

### 3.函数名重定义

C/C++语言通过编译器将所有源文件编译为目标文件，再通过链接器将其链接为一个可执行文件。如果两个源文件中包含相同定义的函数，那么就会在链接过程出现重定义问题。

通常来说，为了避免这个问题，有如下几种解决方案：

- 如果函数不需要暴露给其他头文件，可以使其变为static函数，这样这个函数仅会在本源文件有效，不会污染其他源文件
- 在所有函数名前加入一些特殊的标志，用于表明其位于哪个源文件或者哪个库。这也是大多数C语言库的做法，比如OpenGL的库函数均以GL开头。
- C++中，可以通过**命名空间**来分割管理代码。就像C++标准库的代码均位于std命名空间下，所有的源文件都可以定义一个命名空间来将其分割。这种做法有着深远影响，现代几乎所有流行编程语言都支持类似命名空间的机制，例如Java的包，Rust的模块。

### 4.代码过于冗长，不便阅览

目前来说缩短代码可以通过；

- 将代码分割到不同文件
- 频繁出现的功能性代码块包装为函数或宏
- 采用合适的格式化工具使代码便于阅读
- 保持代码缩进同时增加适当的空行空格来使代码风格松散而优雅。
- 重新整理代码，或者说**重构**

### 5.某些符号的位置总是出错

请将输入法切换到英文模式，并确保输入字符为半角。

### 6.循环没有按照预期运行

为了保险起见，请把所有循环的代码块包括在`{}`中，以免由于代码格式问题导致循环错误执行。

注意到`i++`和`++i`的运作方式不同。请尽量避免这类代码，而使用`i += 1;`这样清晰明了的方式代替。

### 7.发生调用栈溢出异常

这通常是由于对函数的递归使用造成的，这是由于函数在栈中存储着自身作用域的各种数据，包括参数，调用层次过深会导致系统分配的调用栈溢出；也有小概率出现在嵌套层次过于深的代码中。对于前者，解决方法通常有：

- 使用**尾递归**的递归形式，即只在函数结尾时递归调用并立即返回。大多数编译器对尾递归有着特殊优化，在尾递归时无需存储递归各级的函数栈，从而降低调用栈溢出的问题。
- 使用循环替代。所有的递归都可以写成循环形式，这可以完全阻止调用栈溢出的问题，也是工程代码最标准的形式。
- 优化算法。一个更为优异的算法往往可以大幅减少递归次数，比如使用之前计算得出的结果的缓存。

### 8.代码卡死了

检查循环是否为死循环，确保循环在运行时是可退出的。

### 9.程序跑得很慢

检查循环的算法是否还能优化。往往O(1)的算法是优于O(n)的，而O(n)的算法也是优于O(n^2)的。如果能在编译期就完成的计算，就不要拖到运行时计算。

另一方面，空间复杂度的提升。虽然如今计算机内存的大小已经今非夕比，但循环无限分配内存的问题仍是不可接受的。

### 10.C中无法调用C++的函数

检查下C++的函数是否包含了C++独有的参数或返回值，同时在导出函数前加上`extern "C"`以确保导出函数为C函数形式。

### 11.头文件重复包含

在每个头文件后前加上：

```C
#ifndef __SOME_H__
#define __SOME_H__
// 你的代码
#endif
```

通过宏定义和检查宏是否定义来确保头文件只被包含一次。这也是工程项目标准做法。

### 12.头文件带来的命名空间污染

由于头文件实际会替换包含头文件指令的位置，这导致头文件中包含的代码会污染源文件，例如`using namespace std;`在头文件中使用会导致源文件中可以直接使用`std`下的函数，类型等。

因而，头文件应杜绝带有副作用的操作，如果需要使用命名空间内内容，请用`std::cout`这样的完整形式使用。

## 四、进阶

### 1.构建工具

合适的构建工具使得你的项目可以跨平台并且不受其他开发工具（如IDE）的影响。目前流行的构建工具有：

- make：最为传统的构建工具，实质上是一种构建脚本，通过编写脚本来构建项目同时减少重复编译的开销
- cmake：最为常用的构建，可以进行依赖管理，项目的设置等项目开发常用功能。它可以生成makefile或者ninja文件来进行构建。
- xmake：最现代化的构建工具，实际表现类似于`cargo`这样的现代化构建工具，可以进行包管理，虚拟环境，构建项目，多语言结合等工作。

### 2.宏

合适的宏可以帮你减少代码量。

宏是简单的文本替换，可能有参数，也可能没有，但最终都是根据简单的规则进行文本替换。比如定义`printf_z`来让我们的输出总是在之前带一些文本···

```C
#define printf_z(fmt, ...) printf("[Prefix]" fmt, ##__VA_ARGS__)
```

宏是强大的，但也务必注意过多的宏可能导致你的代码变得诡异而难以理解，请务必合理使用宏。

### 3.智能指针

时至今日已经鲜有人使用C++中的普通指针，它们管理起来给程序员造成了很大的心理负担：你必须记住去释放他们，不然就会造成内存泄露。

使用`std::make_shared`或者`std::make_unique`可以创建智能指针，它可以替你进行内存管理并用于参数传递，解放了程序员的大脑用于其他更为重要的场合。

shared智能指针可以任意共享，并可以同时进行读写，而unique指针会独占数据，不允许同时读写。

### 4.auto

C++将早就不再使用的`auto`关键字（曾用于指明栈上自动分配内存的变量）复用为推断类型关键字，即编译期自动推断出的类型，无需你亲自指明，它可以用于：

- 定义变量时类型名很长很复杂不想写时，比如`auto a = std::make_shared(1)`
- 将函数返回值类型后置，比如`auto main() -> int`
- 单纯偷懒，毕竟不是每个人都想注明所有变量的类型的

如今在C23标准中也引入了这个特性，不过目前还没有广泛支持。
